import { Component, OnInit, Input, Output, HostListener, ElementRef, EventEmitter, Renderer2, OnChanges, SimpleChanges } from '@angular/core';
import { CartItem } from '../interfaces/cart';
import { CartService } from '../services/cart.service';
import { Router } from '@angular/router';
import { UserService } from '../services/user.service';
import { CustomerService } from '../services/customer.service';
import { CartItem1 } from '../interfaces/customer';
import { map } from 'rxjs/operators';
import { forkJoin } from 'rxjs';  // Import forkJoin t·ª´ rxjs
import { ProductService } from '../services/product.service';
import { CartpaymentService } from '../services/cartpayment.service'; 


@Component({
  selector: 'app-sidebar',
  standalone: false,
  templateUrl: './sidebar.component.html',
  styleUrl: './sidebar.component.css',
})
export class SidebarComponent implements OnInit, OnChanges {
  @Input() isVisible: boolean = false; // Receive sidebar state from parent
  @Output() closeSidebarEvent = new EventEmitter<void>(); // Emit close event to parent

  currentUserPhone: string | null = null;
  isUserLoggedIn: boolean = false;

  selectedProductIds: Set<string> = new Set();


  // Add isHiding property to control animation
  isHiding: boolean = false;
  isClosing: boolean = false;

  // Danh s√°ch s·∫£n ph·∫©m trong gi·ªè h√†ng
  products: CartItem[] = [];  // Danh s√°ch s·∫£n ph·∫©m trong gi·ªè h√†ng
  total: number = 0; // T·ªïng gi·ªè h√†ng
  private hasInitialized = false;
  private isFirstLoad = true;
  public cartContentLoaded = false;
  constructor(
    private userService: UserService,
    private customerService: CustomerService,
    private cartService: CartService,
    private productService: ProductService,
    private cartpaymentService: CartpaymentService,
    private router: Router,
    private renderer: Renderer2,
    private elementRef: ElementRef  // L·∫•y tham chi·∫øu ƒë·∫øn sidebar
  ) {}

  // Ki·ªÉm tra gi·ªè h√†ng c√≥ tr·ªëng hay kh√¥ng
  get isEmpty(): boolean {
    return this.products.length === 0;
  }

  loadCartByPhone(phone: string) {
    if (!phone || !this.isUserLoggedIn) {
      console.log("‚ùå Kh√¥ng c√≥ s·ªë ƒëi·ªán tho·∫°i h·ª£p l·ªá ho·∫∑c ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng xu·∫•t.");
      this.products = []; // X√≥a gi·ªè h√†ng ngay khi ƒëƒÉng xu·∫•t
      this.updateTotal();
      return;
    }
    // if (!phone) return;
    
    console.log("üì¢ G·ªçi API l·∫•y gi·ªè h√†ng v·ªõi s·ªë ƒëi·ªán tho·∫°i:", phone);
    this.cartContentLoaded = false;
  
    // G·ªçi API l·∫•y gi·ªè h√†ng t·ª´ Database
    this.customerService.getCartByPhone(phone).subscribe(
      (cartItems: CartItem1[]) => {
        console.log("‚úÖ Gi·ªè h√†ng t·ª´ Database:", cartItems);
  
        if (cartItems.length === 0) {
          console.log("üõí Gi·ªè h√†ng tr·ªëng!");
          this.products = [];
          this.updateTotal();
          this.cartContentLoaded = true;
          return;
        }
  
        // G·ª≠i request l·∫•y th√¥ng tin s·∫£n ph·∫©m
        const productRequests = cartItems.map(item =>
          this.productService.getProductDetails(item.productId).pipe(
            map(productDetails => {
              productDetails.cartQuantity = item.cartQuantity;
              return productDetails;
            })
          )
        );
  
        // G·ªçi API l·∫•y chi ti·∫øt s·∫£n ph·∫©m
        forkJoin(productRequests).subscribe(
          (products: CartItem[]) => {
            this.products = products;
            this.updateTotal();
            console.log("‚úÖ ƒê√£ t·∫£i", products.length, "s·∫£n ph·∫©m t·ª´ database");
            this.cartContentLoaded = true;
          },
          error => {
            console.error('‚ùå L·ªói khi l·∫•y th√¥ng tin s·∫£n ph·∫©m:', error);
            this.cartContentLoaded = true;
          }
        );
      },
      error => {
        console.error('‚ùå L·ªói khi t·∫£i gi·ªè h√†ng t·ª´ database:', error);
        this.cartContentLoaded = true;
      }
    );
  }

  loadProducts(): void {
    // Ch·ªâ t·∫£i s·∫£n ph·∫©m khi sidebar th·ª±c s·ª± ƒë∆∞·ª£c hi·ªÉn th·ªã
    if (!this.isVisible) return;
    
    // ƒê√°nh d·∫•u ƒëang t·∫£i d·ªØ li·ªáu
    this.cartContentLoaded = false;
    
    this.cartService.getCartItems().subscribe({
      next: (data) => {
        this.products = this.formatProducts(data);
        this.updateTotal();
        
        // ƒê√°nh d·∫•u ƒë√£ t·∫£i xong
        this.cartContentLoaded = true;
        
        // Kh√¥ng n√™n t·ª± ƒë·ªông ƒë√≥ng sidebar khi gi·ªè h√†ng tr·ªëng
        // X√≥a ƒëo·∫°n code t·ª± ƒë·ªông ƒë√≥ng sidebar ·ªü ƒë√¢y
      },
      error: (err) => {
        console.error('Error loading cart:', err);
        this.cartContentLoaded = true; // ƒê·∫£m b·∫£o ƒë√°nh d·∫•u ho√†n th√†nh ngay c·∫£ khi c√≥ l·ªói
      }
    });
  }
  
  resetSidebar() {
    this.products = [];
    this.total = 0;
    this.isHiding = false;
  }
  
    
  ngOnInit(): void {
    console.log('Sidebar initialized with isVisible:', this.isVisible);
    this.hasInitialized = true;
    this.isFirstLoad = true;
    
    // ƒê·∫£m b·∫£o sidebar kh·ªüi ƒë·ªông ·∫©n
    if (this.isVisible) {
      // N·∫øu isVisible ƒë∆∞·ª£c ƒë·∫∑t th√†nh true trong qu√° tr√¨nh kh·ªüi t·∫°o, ƒë·∫∑t l·∫°i th√†nh false
      setTimeout(() => {
        if (this.isVisible && this.isFirstLoad) {
          this.closeCart();
        }
      }, 0);
    }

    this.userService.currentUserPhone$.subscribe((phone: string | null) => {
      const wasLoggedIn = this.isUserLoggedIn;
      this.currentUserPhone = phone;
      this.isUserLoggedIn = !!phone;
    
      if (wasLoggedIn && !this.isUserLoggedIn) {
        console.log("üì¢ Ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng xu·∫•t, x√≥a gi·ªè h√†ng c≈©");
        
        this.resetSidebar(); // X√≥a gi·ªè h√†ng tr√™n giao di·ªán
        
        this.cartService.clearCart().subscribe({
          next: () => {
            console.log("‚úÖ Gi·ªè h√†ng trong session ƒë√£ ƒë∆∞·ª£c x√≥a.");
            
            if (this.isVisible) {
              setTimeout(() => {
                this.products = [];
                this.loadProducts(); // Load l·∫°i gi·ªè h√†ng r·ªóng
              }, 100);
            }
          },
          error: (err) => {
            console.error("‚ùå L·ªói khi x√≥a gi·ªè h√†ng:", err);
          }
        });
      } else if (this.isVisible && phone) {
        console.log("üì¢ Ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p, t·∫£i gi·ªè h√†ng t·ª´ database:", phone);
        this.loadCartByPhone(phone);
      } else if (this.isVisible) {
        console.log("‚ö† Ng∆∞·ªùi d√πng ch∆∞a ƒëƒÉng nh·∫≠p, t·∫£i gi·ªè h√†ng t·ª´ session.");
        this.loadProducts();
      }
    });
  }


  private formatProducts(data: CartItem[]): CartItem[] {
    return data.map((product) => {
      if (product.Image && typeof product.Image === 'string') {
        try {
          const images = JSON.parse(product.Image);
          product.Image = images[0];
        } catch (e) {
          console.error('Error parsing images for product:', product.Name, e);
          product.Image = '';
        }
      }
      return product;
    });
  }
  
  // Thay ƒë·ªïi s·ªë l∆∞·ª£ng s·∫£n ph·∫©m khi nh·∫•n c√°c n√∫t
  changeQuantity(action: string, productId: string): void {
    const product = this.products.find(p => p.productId === productId);
    if (!product) return;

    // TƒÉng ho·∫∑c gi·∫£m s·ªë l∆∞·ª£ng s·∫£n ph·∫©m
    if (action === 'increase') {
      product.cartQuantity++;
    } else if (action === 'decrease' && product.cartQuantity > 1) {
      product.cartQuantity--;
    } else if (action === 'decrease' && product.cartQuantity === 1) {
      this.removeProduct(productId); // X√≥a s·∫£n ph·∫©m khi s·ªë l∆∞·ª£ng gi·∫£m xu·ªëng 0
      return;
    }

    // C·∫≠p nh·∫≠t t·ªïng gi·ªè h√†ng
    this.updateTotal();
    // G·ªçi ph∆∞∆°ng th·ª©c updateCartItem ƒë·ªÉ c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng l√™n server
    this.cartService.updateCartItem(product.productId, product.cartQuantity).subscribe({
      next: () => {
      },
      error: (err) => {
        console.error('Error updating item quantity:', err);
      }
    });

      // üî• N·∫øu kh√°ch h√†ng ƒë√£ ƒëƒÉng nh·∫≠p, c·∫≠p nh·∫≠t gi·ªè h√†ng l√™n server
  if (this.isUserLoggedIn && this.currentUserPhone) {
    this.updateCustomerCartOnServer();
  }
  }


  // G·ª≠i gi·ªè h√†ng c·ªßa kh√°ch h√†ng l√™n server ƒë·ªÉ c·∫≠p nh·∫≠t database
updateCustomerCartOnServer(): void {
  if (!this.currentUserPhone) return;

  // L·∫•y gi·ªè h√†ng m·ªõi ƒë·ªÉ g·ª≠i l√™n server
  const updatedCart = this.products.map(product => ({
    productId: product.productId,
    cartQuantity: product.cartQuantity
  }));

  console.log("üì¢ G·ª≠i gi·ªè h√†ng m·ªõi l√™n server:", updatedCart);

  // G·ªçi API c·∫≠p nh·∫≠t gi·ªè h√†ng c·ªßa kh√°ch h√†ng tr√™n server
  this.customerService.updateCustomerCart(this.currentUserPhone, updatedCart).subscribe({
    next: () => {
      console.log("‚úÖ Gi·ªè h√†ng c·ªßa kh√°ch h√†ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t tr√™n server.");
    },
    error: (err) => {
      console.error("‚ùå L·ªói khi c·∫≠p nh·∫≠t gi·ªè h√†ng tr√™n server:", err);
    }
  });
}


  // X√≥a s·∫£n ph·∫©m khi s·ªë l∆∞·ª£ng = 0
  removeProduct(productId: string): void {
    const index = this.products.findIndex(p => p.productId === productId);
    
    if (index !== -1) {
      this.products.splice(index, 1); // X√≥a s·∫£n ph·∫©m kh·ªèi giao di·ªán
      this.updateTotal(); // C·∫≠p nh·∫≠t l·∫°i t·ªïng gi·ªè h√†ng
  
      // G·ª≠i y√™u c·∫ßu API ƒë·ªÉ x√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng tr√™n server
      this.cartService.removeCartItem(productId).subscribe({
        next: () => {
          console.log(`Product ${productId} removed from cart on server.`);
        },
        error: (err) => {
          console.error('Error removing product from cart:', err);
        }
      });
    }
     // üî• N·∫øu kh√°ch h√†ng ƒë√£ ƒëƒÉng nh·∫≠p, c·∫≠p nh·∫≠t gi·ªè h√†ng l√™n server
     if (this.isUserLoggedIn && this.currentUserPhone) {
      this.updateCustomerCartOnServer();
    }
  }

  // C·∫≠p nh·∫≠t t·ªïng gi·ªè h√†ng
  updateTotal(): void {
    this.total = this.products.reduce((acc, product) => acc + (product.cartQuantity * product.Price), 0);
  }

  closeCart(): void {
    // Ch·ªâ ƒë·∫∑t tr·∫°ng th√°i ƒëang ƒë√≥ng
    this.isClosing = true;
    
    // ƒê·ª£i hi·ªáu ·ª©ng ho√†n th√†nh tr∆∞·ªõc khi th·ª±c s·ª± ƒë√≥ng
    setTimeout(() => {
      this.closeSidebarEvent.emit(); // Th√¥ng b√°o cho component cha
      document.body.style.overflow = ''; // Cho ph√©p cu·ªôn trang
      this.isClosing = false; // ƒê·∫∑t l·∫°i tr·∫°ng th√°i
    }, 300); // Th·ªùi gian transition
  }
  // Only listen for clicks if sidebar is visible
  @HostListener('document:click', ['$event'])
  onClickOutside(event: Event): void {
    if (this.isVisible && !this.elementRef.nativeElement.contains(event.target as Node)) {
      this.closeCart();
    }
  }

  navigateToCart() {
    this.closeCart(); // ƒê√≥ng sidebar tr∆∞·ªõc
    this.router.navigate(['/cart-page']); // Chuy·ªÉn ƒë·∫øn trang gi·ªè h√†ng
  }

  clearCart(): void {
    this.products = [];
    this.total = 0;
    this.cartService.clearCart().subscribe({
      next: () => {
        console.log("Gi·ªè h√†ng ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng");
      },
      error: (err) => {
        console.error("L·ªói khi x√≥a gi·ªè h√†ng:", err);
      }
    });
  }
  ngOnChanges(changes: SimpleChanges): void {
    if (this.hasInitialized && changes['isVisible']) {
      if (this.isVisible) {
        // Khi m·ªü sidebar
        this.isClosing = false;
        this.renderer.addClass(document.body, 'no-scroll');
        document.body.style.overflow = 'hidden';
        if (this.isUserLoggedIn && this.currentUserPhone) {
          this.loadCartByPhone(this.currentUserPhone);
        } else {
          this.loadProducts();
        }
      } else {
        // Khi ƒë√≥ng sidebar, ch·ªâ reset state m√† kh√¥ng thay ƒë·ªïi animation
        this.renderer.removeClass(document.body, 'no-scroll');
        document.body.style.overflow = '';
        
        // Kh√¥ng reset sidebar ngay l·∫≠p t·ª©c
        setTimeout(() => {
          if (!this.isVisible) {
            this.resetSidebar();
          }
        }, 300);
      }
    }
  }
  
}